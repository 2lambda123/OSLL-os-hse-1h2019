diff --git a/kern/kdebug.c b/kern/kdebug.c
index 9547143..26540a6 100644
--- a/kern/kdebug.c
+++ b/kern/kdebug.c
@@ -1,206 +1,210 @@
-#include <inc/stab.h>
-#include <inc/string.h>
-#include <inc/memlayout.h>
-#include <inc/assert.h>
-
-#include <kern/kdebug.h>
-
-extern const struct Stab __STAB_BEGIN__[];	// Beginning of stabs table
-extern const struct Stab __STAB_END__[];	// End of stabs table
-extern const char __STABSTR_BEGIN__[];		// Beginning of string table
-extern const char __STABSTR_END__[];		// End of string table
-
-
-// stab_binsearch(stabs, region_left, region_right, type, addr)
-//
-//	Some stab types are arranged in increasing order by instruction
-//	address.  For example, N_FUN stabs (stab entries with n_type ==
-//	N_FUN), which mark functions, and N_SO stabs, which mark source files.
-//
-//	Given an instruction address, this function finds the single stab
-//	entry of type 'type' that contains that address.
-//
-//	The search takes place within the range [*region_left, *region_right].
-//	Thus, to search an entire set of N stabs, you might do:
-//
-//		left = 0;
-//		right = N - 1;     /* rightmost stab */
-//		stab_binsearch(stabs, &left, &right, type, addr);
-//
-//	The search modifies *region_left and *region_right to bracket the
-//	'addr'.  *region_left points to the matching stab that contains
-//	'addr', and *region_right points just before the next stab.  If
-//	*region_left > *region_right, then 'addr' is not contained in any
-//	matching stab.
-//
-//	For example, given these N_SO stabs:
-//		Index  Type   Address
-//		0      SO     f0100000
-//		13     SO     f0100040
-//		117    SO     f0100176
-//		118    SO     f0100178
-//		555    SO     f0100652
-//		556    SO     f0100654
-//		657    SO     f0100849
-//	this code:
-//		left = 0, right = 657;
-//		stab_binsearch(stabs, &left, &right, N_SO, 0xf0100184);
-//	will exit setting left = 118, right = 554.
-//
-static void
-stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
-	       int type, uintptr_t addr)
-{
-	int l = *region_left, r = *region_right, any_matches = 0;
-
-	while (l <= r) {
-		int true_m = (l + r) / 2, m = true_m;
-
-		// search for earliest stab with right type
-		while (m >= l && stabs[m].n_type != type)
-			m--;
-		if (m < l) {	// no match in [l, m]
-			l = true_m + 1;
-			continue;
-		}
-
-		// actual binary search
-		any_matches = 1;
-		if (stabs[m].n_value < addr) {
-			*region_left = m;
-			l = true_m + 1;
-		} else if (stabs[m].n_value > addr) {
-			*region_right = m - 1;
-			r = m - 1;
-		} else {
-			// exact match for 'addr', but continue loop to find
-			// *region_right
-			*region_left = m;
-			l = m;
-			addr++;
-		}
-	}
-
-	if (!any_matches)
-		*region_right = *region_left - 1;
-	else {
-		// find rightmost region containing 'addr'
-		for (l = *region_right;
-		     l > *region_left && stabs[l].n_type != type;
-		     l--)
-			/* do nothing */;
-		*region_left = l;
-	}
-}
-
-
-// debuginfo_eip(addr, info)
-//
-//	Fill in the 'info' structure with information about the specified
-//	instruction address, 'addr'.  Returns 0 if information was found, and
-//	negative if not.  But even if it returns negative it has stored some
-//	information into '*info'.
-//
-int
-debuginfo_eip(uintptr_t addr, struct Eipdebuginfo *info)
-{
-	const struct Stab *stabs, *stab_end;
-	const char *stabstr, *stabstr_end;
-	int lfile, rfile, lfun, rfun, lline, rline;
-
-	// Initialize *info
-	info->eip_file = "<unknown>";
-	info->eip_line = 0;
-	info->eip_fn_name = "<unknown>";
-	info->eip_fn_namelen = 9;
-	info->eip_fn_addr = addr;
-	info->eip_fn_narg = 0;
-
-	// Find the relevant set of stabs
-	if (addr >= ULIM) {
-		stabs = __STAB_BEGIN__;
-		stab_end = __STAB_END__;
-		stabstr = __STABSTR_BEGIN__;
-		stabstr_end = __STABSTR_END__;
-	} else {
-		// Can't search for user-level addresses yet!
-  	        panic("User address");
-	}
-
-	// String table validity checks
-	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
-		return -1;
-
-	// Now we find the right stabs that define the function containing
-	// 'eip'.  First, we find the basic source file containing 'eip'.
-	// Then, we look in that source file for the function.  Then we look
-	// for the line number.
-
-	// Search the entire set of stabs for the source file (type N_SO).
-	lfile = 0;
-	rfile = (stab_end - stabs) - 1;
-	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
-	if (lfile == 0)
-		return -1;
-
-	// Search within that file's stabs for the function definition
-	// (N_FUN).
-	lfun = lfile;
-	rfun = rfile;
-	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
-
-	if (lfun <= rfun) {
-		// stabs[lfun] points to the function name
-		// in the string table, but check bounds just in case.
-		if (stabs[lfun].n_strx < stabstr_end - stabstr)
-			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
-		info->eip_fn_addr = stabs[lfun].n_value;
-		addr -= info->eip_fn_addr;
-		// Search within the function definition for the line number.
-		lline = lfun;
-		rline = rfun;
-	} else {
-		// Couldn't find function stab!  Maybe we're in an assembly
-		// file.  Search the whole file for the line number.
-		info->eip_fn_addr = addr;
-		lline = lfile;
-		rline = rfile;
-	}
-	// Ignore stuff after the colon.
-	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
-
-
-	// Search within [lline, rline] for the line number stab.
-	// If found, set info->eip_line to the right line number.
-	// If not found, return -1.
-	//
-	// Hint:
-	//	There's a particular stabs type used for line numbers.
-	//	Look at the STABS documentation and <inc/stab.h> to find
-	//	which one.
-	// Your code here.
-
-
-	// Search backwards from the line number for the relevant filename
-	// stab.
-	// We can't just use the "lfile" stab because inlined functions
-	// can interpolate code from a different file!
-	// Such included source files use the N_SOL stab type.
-	while (lline >= lfile
-	       && stabs[lline].n_type != N_SOL
-	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
-		lline--;
-	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
-		info->eip_file = stabstr + stabs[lline].n_strx;
-
-
-	// Set eip_fn_narg to the number of arguments taken by the function,
-	// or 0 if there was no containing function.
-	if (lfun < rfun)
-		for (lline = lfun + 1;
-		     lline < rfun && stabs[lline].n_type == N_PSYM;
-		     lline++)
-			info->eip_fn_narg++;
-
-	return 0;
-}
+#include <inc/stab.h>
+#include <inc/string.h>
+#include <inc/memlayout.h>
+#include <inc/assert.h>
+
+#include <kern/kdebug.h>
+
+extern const struct Stab __STAB_BEGIN__[];	// Beginning of stabs table
+extern const struct Stab __STAB_END__[];	// End of stabs table
+extern const char __STABSTR_BEGIN__[];		// Beginning of string table
+extern const char __STABSTR_END__[];		// End of string table
+
+
+// stab_binsearch(stabs, region_left, region_right, type, addr)
+//
+//	Some stab types are arranged in increasing order by instruction
+//	address.  For example, N_FUN stabs (stab entries with n_type ==
+//	N_FUN), which mark functions, and N_SO stabs, which mark source files.
+//
+//	Given an instruction address, this function finds the single stab
+//	entry of type 'type' that contains that address.
+//
+//	The search takes place within the range [*region_left, *region_right].
+//	Thus, to search an entire set of N stabs, you might do:
+//
+//		left = 0;
+//		right = N - 1;     /* rightmost stab */
+//		stab_binsearch(stabs, &left, &right, type, addr);
+//
+//	The search modifies *region_left and *region_right to bracket the
+//	'addr'.  *region_left points to the matching stab that contains
+//	'addr', and *region_right points just before the next stab.  If
+//	*region_left > *region_right, then 'addr' is not contained in any
+//	matching stab.
+//
+//	For example, given these N_SO stabs:
+//		Index  Type   Address
+//		0      SO     f0100000
+//		13     SO     f0100040
+//		117    SO     f0100176
+//		118    SO     f0100178
+//		555    SO     f0100652
+//		556    SO     f0100654
+//		657    SO     f0100849
+//	this code:
+//		left = 0, right = 657;
+//		stab_binsearch(stabs, &left, &right, N_SO, 0xf0100184);
+//	will exit setting left = 118, right = 554.
+//
+static void
+stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
+	       int type, uintptr_t addr)
+{
+	int l = *region_left, r = *region_right, any_matches = 0;
+
+	while (l <= r) {
+		int true_m = (l + r) / 2, m = true_m;
+
+		// search for earliest stab with right type
+		while (m >= l && stabs[m].n_type != type)
+			m--;
+		if (m < l) {	// no match in [l, m]
+			l = true_m + 1;
+			continue;
+		}
+
+		// actual binary search
+		any_matches = 1;
+		if (stabs[m].n_value < addr) {
+			*region_left = m;
+			l = true_m + 1;
+		} else if (stabs[m].n_value > addr) {
+			*region_right = m - 1;
+			r = m - 1;
+		} else {
+			// exact match for 'addr', but continue loop to find
+			// *region_right
+			*region_left = m;
+			l = m;
+			addr++;
+		}
+	}
+
+	if (!any_matches)
+		*region_right = *region_left - 1;
+	else {
+		// find rightmost region containing 'addr'
+		for (l = *region_right;
+		     l > *region_left && stabs[l].n_type != type;
+		     l--)
+			/* do nothing */;
+		*region_left = l;
+	}
+}
+
+
+// debuginfo_eip(addr, info)
+//
+//	Fill in the 'info' structure with information about the specified
+//	instruction address, 'addr'.  Returns 0 if information was found, and
+//	negative if not.  But even if it returns negative it has stored some
+//	information into '*info'.
+//
+int
+debuginfo_eip(uintptr_t addr, struct Eipdebuginfo *info)
+{
+	const struct Stab *stabs, *stab_end;
+	const char *stabstr, *stabstr_end;
+	int lfile, rfile, lfun, rfun, lline, rline;
+
+	// Initialize *info
+	info->eip_file = "<unknown>";
+	info->eip_line = 0;
+	info->eip_fn_name = "<unknown>";
+	info->eip_fn_namelen = 9;
+	info->eip_fn_addr = addr;
+	info->eip_fn_narg = 0;
+
+	// Find the relevant set of stabs
+	if (addr >= ULIM) {
+		stabs = __STAB_BEGIN__;
+		stab_end = __STAB_END__;
+		stabstr = __STABSTR_BEGIN__;
+		stabstr_end = __STABSTR_END__;
+	} else {
+		// Can't search for user-level addresses yet!
+  	        panic("User address");
+	}
+
+	// String table validity checks
+	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
+		return -1;
+
+	// Now we find the right stabs that define the function containing
+	// 'eip'.  First, we find the basic source file containing 'eip'.
+	// Then, we look in that source file for the function.  Then we look
+	// for the line number.
+
+	// Search the entire set of stabs for the source file (type N_SO).
+	lfile = 0;
+	rfile = (stab_end - stabs) - 1;
+	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
+	if (lfile == 0)
+		return -1;
+
+	// Search within that file's stabs for the function definition
+	// (N_FUN).
+	lfun = lfile;
+	rfun = rfile;
+	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
+
+	if (lfun <= rfun) {
+		// stabs[lfun] points to the function name
+		// in the string table, but check bounds just in case.
+		if (stabs[lfun].n_strx < stabstr_end - stabstr)
+			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
+		info->eip_fn_addr = stabs[lfun].n_value;
+		addr -= info->eip_fn_addr;
+		// Search within the function definition for the line number.
+		lline = lfun;
+		rline = rfun;
+	} else {
+		// Couldn't find function stab!  Maybe we're in an assembly
+		// file.  Search the whole file for the line number.
+		info->eip_fn_addr = addr;
+		lline = lfile;
+		rline = rfile;
+	}
+	// Ignore stuff after the colon.
+	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
+
+
+	// Search within [lline, rline] for the line number stab.
+	// If found, set info->eip_line to the right line number.
+	// If not found, return -1.
+	//
+	// Hint:
+	//	There's a particular stabs type used for line numbers.
+	//	Look at the STABS documentation and <inc/stab.h> to find
+	//	which one.
+
+	stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
+	if (rline < lline)
+	    return -1;
+	info->eip_line = stabs[lline].n_desc;
+
+
+	// Search backwards from the line number for the relevant filename
+	// stab.
+	// We can't just use the "lfile" stab because inlined functions
+	// can interpolate code from a different file!
+	// Such included source files use the N_SOL stab type.
+	while (lline >= lfile
+	       && stabs[lline].n_type != N_SOL
+	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
+		lline--;
+	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
+		info->eip_file = stabstr + stabs[lline].n_strx;
+
+
+	// Set eip_fn_narg to the number of arguments taken by the function,
+	// or 0 if there was no containing function.
+	if (lfun < rfun)
+		for (lline = lfun + 1;
+		     lline < rfun && stabs[lline].n_type == N_PSYM;
+		     lline++)
+			info->eip_fn_narg++;
+
+	return 0;
+}
diff --git a/kern/monitor.c b/kern/monitor.c
index f8a934a..6cdbab1 100644
--- a/kern/monitor.c
+++ b/kern/monitor.c
@@ -1,126 +1,143 @@
-// Simple command-line kernel monitor useful for
-// controlling the kernel and exploring the system interactively.
-
-#include <inc/stdio.h>
-#include <inc/string.h>
-#include <inc/memlayout.h>
-#include <inc/assert.h>
-#include <inc/x86.h>
-
-#include <kern/console.h>
-#include <kern/monitor.h>
-#include <kern/kdebug.h>
-
-#define CMDBUF_SIZE	80	// enough for one VGA text line
-
-
-struct Command {
-	const char *name;
-	const char *desc;
-	// return -1 to force monitor to exit
-	int (*func)(int argc, char** argv, struct Trapframe* tf);
-};
-
-static struct Command commands[] = {
-	{ "help", "Display this list of commands", mon_help },
-	{ "kerninfo", "Display information about the kernel", mon_kerninfo },
-};
-#define NCOMMANDS (sizeof(commands)/sizeof(commands[0]))
-
-/***** Implementations of basic kernel monitor commands *****/
-
-int
-mon_help(int argc, char **argv, struct Trapframe *tf)
-{
-	int i;
-
-	for (i = 0; i < NCOMMANDS; i++)
-		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
-	return 0;
-}
-
-int
-mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
-{
-	extern char _start[], entry[], etext[], edata[], end[];
-
-	cprintf("Special kernel symbols:\n");
-	cprintf("  _start                  %08x (phys)\n", _start);
-	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
-	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
-	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
-	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
-	cprintf("Kernel executable memory footprint: %dKB\n",
-		ROUNDUP(end - entry, 1024) / 1024);
-	return 0;
-}
-
-int
-mon_backtrace(int argc, char **argv, struct Trapframe *tf)
-{
-	// Your code here.
-	return 0;
-}
-
-
-
-/***** Kernel monitor command interpreter *****/
-
-#define WHITESPACE "\t\r\n "
-#define MAXARGS 16
-
-static int
-runcmd(char *buf, struct Trapframe *tf)
-{
-	int argc;
-	char *argv[MAXARGS];
-	int i;
-
-	// Parse the command buffer into whitespace-separated arguments
-	argc = 0;
-	argv[argc] = 0;
-	while (1) {
-		// gobble whitespace
-		while (*buf && strchr(WHITESPACE, *buf))
-			*buf++ = 0;
-		if (*buf == 0)
-			break;
-
-		// save and scan past next arg
-		if (argc == MAXARGS-1) {
-			cprintf("Too many arguments (max %d)\n", MAXARGS);
-			return 0;
-		}
-		argv[argc++] = buf;
-		while (*buf && !strchr(WHITESPACE, *buf))
-			buf++;
-	}
-	argv[argc] = 0;
-
-	// Lookup and invoke the command
-	if (argc == 0)
-		return 0;
-	for (i = 0; i < NCOMMANDS; i++) {
-		if (strcmp(argv[0], commands[i].name) == 0)
-			return commands[i].func(argc, argv, tf);
-	}
-	cprintf("Unknown command '%s'\n", argv[0]);
-	return 0;
-}
-
-void
-monitor(struct Trapframe *tf)
-{
-	char *buf;
-
-	cprintf("Welcome to the JOS kernel monitor!\n");
-	cprintf("Type 'help' for a list of commands.\n");
-
-
-	while (1) {
-		buf = readline("K> ");
-		if (buf != NULL)
-			if (runcmd(buf, tf) < 0)
-				break;
-	}
-}
+// Simple command-line kernel monitor useful for
+// controlling the kernel and exploring the system interactively.
+
+#include <inc/stdio.h>
+#include <inc/string.h>
+#include <inc/memlayout.h>
+#include <inc/assert.h>
+#include <inc/x86.h>
+
+#include <kern/console.h>
+#include <kern/monitor.h>
+#include <kern/kdebug.h>
+
+#define CMDBUF_SIZE	80	// enough for one VGA text line
+
+
+struct Command {
+	const char *name;
+	const char *desc;
+	// return -1 to force monitor to exit
+	int (*func)(int argc, char** argv, struct Trapframe* tf);
+};
+
+static struct Command commands[] = {
+	{ "help", "Display this list of commands", mon_help },
+	{ "kerninfo", "Display information about the kernel", mon_kerninfo },
+};
+#define NCOMMANDS (sizeof(commands)/sizeof(commands[0]))
+
+/***** Implementations of basic kernel monitor commands *****/
+
+int
+mon_help(int argc, char **argv, struct Trapframe *tf)
+{
+	int i;
+
+	for (i = 0; i < NCOMMANDS; i++)
+		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
+	return 0;
+}
+
+int
+mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
+{
+	extern char _start[], entry[], etext[], edata[], end[];
+
+	cprintf("Special kernel symbols:\n");
+	cprintf("  _start                  %08x (phys)\n", _start);
+	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
+	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
+	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
+	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
+	cprintf("Kernel executable memory footprint: %dKB\n",
+		ROUNDUP(end - entry, 1024) / 1024);
+	return 0;
+}
+
+int
+mon_backtrace(int argc, char **argv, struct Trapframe *tf)
+{
+	uint32_t *ebp = (uint32_t*)read_ebp(), *eip = (uint32_t*)ebp[1];
+    struct Eipdebuginfo eipdebuginfo;
+
+    cprintf("Stack backtrace:\n");
+    while (ebp) {
+        debuginfo_eip((uintptr_t)eip, &eipdebuginfo);
+
+        cprintf("  ebp %08x eip %08x args", ebp, eip);
+        for (int i = 2; i < 7; i++) {
+            cprintf(" %08x", ebp[i]);
+        }
+        cprintf("\n");
+        cprintf("  %s:%d: %.*s+%d\n", eipdebuginfo.eip_file, eipdebuginfo.eip_line, eipdebuginfo.eip_fn_namelen,
+                eipdebuginfo.eip_fn_name, eip - eipdebuginfo.eip_fn_addr);
+
+        ebp = (uint32_t*)*ebp, eip = (uint32_t*)ebp[1];
+    }
+
+	return 0;
+}
+
+
+
+/***** Kernel monitor command interpreter *****/
+
+#define WHITESPACE "\t\r\n "
+#define MAXARGS 16
+
+static int
+runcmd(char *buf, struct Trapframe *tf)
+{
+	int argc;
+	char *argv[MAXARGS];
+	int i;
+
+	// Parse the command buffer into whitespace-separated arguments
+	argc = 0;
+	argv[argc] = 0;
+	while (1) {
+		// gobble whitespace
+		while (*buf && strchr(WHITESPACE, *buf))
+			*buf++ = 0;
+		if (*buf == 0)
+			break;
+
+		// save and scan past next arg
+		if (argc == MAXARGS-1) {
+			cprintf("Too many arguments (max %d)\n", MAXARGS);
+			return 0;
+		}
+		argv[argc++] = buf;
+		while (*buf && !strchr(WHITESPACE, *buf))
+			buf++;
+	}
+	argv[argc] = 0;
+
+	// Lookup and invoke the command
+	if (argc == 0)
+		return 0;
+	for (i = 0; i < NCOMMANDS; i++) {
+		if (strcmp(argv[0], commands[i].name) == 0)
+			return commands[i].func(argc, argv, tf);
+	}
+	cprintf("Unknown command '%s'\n", argv[0]);
+	return 0;
+}
+
+void
+monitor(struct Trapframe *tf)
+{
+	char *buf;
+
+	cprintf("Welcome to the JOS kernel monitor!\n");
+	cprintf("Type 'help' for a list of commands.\n");
+
+
+	while (1) {
+		buf = readline("K> ");
+		if (buf != NULL)
+			if (runcmd(buf, tf) < 0)
+				break;
+	}
+}
diff --git a/lib/printfmt.c b/lib/printfmt.c
index 28e01c9..a61cc1f 100644
--- a/lib/printfmt.c
+++ b/lib/printfmt.c
@@ -1,300 +1,298 @@
-// Stripped-down primitive printf-style formatting routines,
-// used in common by printf, sprintf, fprintf, etc.
-// This code is also used by both the kernel and user programs.
-
-#include <inc/types.h>
-#include <inc/stdio.h>
-#include <inc/string.h>
-#include <inc/stdarg.h>
-#include <inc/error.h>
-
-/*
- * Space or zero padding and a field width are supported for the numeric
- * formats only.
- *
- * The special format %e takes an integer error code
- * and prints a string describing the error.
- * The integer may be positive or negative,
- * so that -E_NO_MEM and E_NO_MEM are equivalent.
- */
-
-static const char * const error_string[MAXERROR] =
-{
-	[E_UNSPECIFIED]	= "unspecified error",
-	[E_BAD_ENV]	= "bad environment",
-	[E_INVAL]	= "invalid parameter",
-	[E_NO_MEM]	= "out of memory",
-	[E_NO_FREE_ENV]	= "out of environments",
-	[E_FAULT]	= "segmentation fault",
-};
-
-/*
- * Print a number (base <= 16) in reverse order,
- * using specified putch function and associated pointer putdat.
- */
-static void
-printnum(void (*putch)(int, void*), void *putdat,
-	 unsigned long long num, unsigned base, int width, int padc)
-{
-	// first recursively print all preceding (more significant) digits
-	if (num >= base) {
-		printnum(putch, putdat, num / base, base, width - 1, padc);
-	} else {
-		// print any needed pad characters before first digit
-		while (--width > 0)
-			putch(padc, putdat);
-	}
-
-	// then print this (the least significant) digit
-	putch("0123456789abcdef"[num % base], putdat);
-}
-
-// Get an unsigned int of various possible sizes from a varargs list,
-// depending on the lflag parameter.
-static unsigned long long
-getuint(va_list *ap, int lflag)
-{
-	if (lflag >= 2)
-		return va_arg(*ap, unsigned long long);
-	else if (lflag)
-		return va_arg(*ap, unsigned long);
-	else
-		return va_arg(*ap, unsigned int);
-}
-
-// Same as getuint but signed - can't use getuint
-// because of sign extension
-static long long
-getint(va_list *ap, int lflag)
-{
-	if (lflag >= 2)
-		return va_arg(*ap, long long);
-	else if (lflag)
-		return va_arg(*ap, long);
-	else
-		return va_arg(*ap, int);
-}
-
-
-// Main function to format and print a string.
-void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);
-
-void
-vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
-{
-	register const char *p;
-	register int ch, err;
-	unsigned long long num;
-	int base, lflag, width, precision, altflag;
-	char padc;
-
-	while (1) {
-		while ((ch = *(unsigned char *) fmt++) != '%') {
-			if (ch == '\0')
-				return;
-			putch(ch, putdat);
-		}
-
-		// Process a %-escape sequence
-		padc = ' ';
-		width = -1;
-		precision = -1;
-		lflag = 0;
-		altflag = 0;
-	reswitch:
-		switch (ch = *(unsigned char *) fmt++) {
-
-		// flag to pad on the right
-		case '-':
-			padc = '-';
-			goto reswitch;
-
-		// flag to pad with 0's instead of spaces
-		case '0':
-			padc = '0';
-			goto reswitch;
-
-		// width field
-		case '1':
-		case '2':
-		case '3':
-		case '4':
-		case '5':
-		case '6':
-		case '7':
-		case '8':
-		case '9':
-			for (precision = 0; ; ++fmt) {
-				precision = precision * 10 + ch - '0';
-				ch = *fmt;
-				if (ch < '0' || ch > '9')
-					break;
-			}
-			goto process_precision;
-
-		case '*':
-			precision = va_arg(ap, int);
-			goto process_precision;
-
-		case '.':
-			if (width < 0)
-				width = 0;
-			goto reswitch;
-
-		case '#':
-			altflag = 1;
-			goto reswitch;
-
-		process_precision:
-			if (width < 0)
-				width = precision, precision = -1;
-			goto reswitch;
-
-		// long flag (doubled for long long)
-		case 'l':
-			lflag++;
-			goto reswitch;
-
-		// character
-		case 'c':
-			putch(va_arg(ap, int), putdat);
-			break;
-
-		// error message
-		case 'e':
-			err = va_arg(ap, int);
-			if (err < 0)
-				err = -err;
-			if (err >= MAXERROR || (p = error_string[err]) == NULL)
-				printfmt(putch, putdat, "error %d", err);
-			else
-				printfmt(putch, putdat, "%s", p);
-			break;
-
-		// string
-		case 's':
-			if ((p = va_arg(ap, char *)) == NULL)
-				p = "(null)";
-			if (width > 0 && padc != '-')
-				for (width -= strnlen(p, precision); width > 0; width--)
-					putch(padc, putdat);
-			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
-				if (altflag && (ch < ' ' || ch > '~'))
-					putch('?', putdat);
-				else
-					putch(ch, putdat);
-			for (; width > 0; width--)
-				putch(' ', putdat);
-			break;
-
-		// (signed) decimal
-		case 'd':
-			num = getint(&ap, lflag);
-			if ((long long) num < 0) {
-				putch('-', putdat);
-				num = -(long long) num;
-			}
-			base = 10;
-			goto number;
-
-		// unsigned decimal
-		case 'u':
-			num = getuint(&ap, lflag);
-			base = 10;
-			goto number;
-
-		// (unsigned) octal
-		case 'o':
-			// Replace this with your code.
-			putch('X', putdat);
-			putch('X', putdat);
-			putch('X', putdat);
-			break;
-
-		// pointer
-		case 'p':
-			putch('0', putdat);
-			putch('x', putdat);
-			num = (unsigned long long)
-				(uintptr_t) va_arg(ap, void *);
-			base = 16;
-			goto number;
-
-		// (unsigned) hexadecimal
-		case 'x':
-			num = getuint(&ap, lflag);
-			base = 16;
-		number:
-			printnum(putch, putdat, num, base, width, padc);
-			break;
-
-		// escaped '%' character
-		case '%':
-			putch(ch, putdat);
-			break;
-
-		// unrecognized escape sequence - just print it literally
-		default:
-			putch('%', putdat);
-			for (fmt--; fmt[-1] != '%'; fmt--)
-				/* do nothing */;
-			break;
-		}
-	}
-}
-
-void
-printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
-{
-	va_list ap;
-
-	va_start(ap, fmt);
-	vprintfmt(putch, putdat, fmt, ap);
-	va_end(ap);
-}
-
-struct sprintbuf {
-	char *buf;
-	char *ebuf;
-	int cnt;
-};
-
-static void
-sprintputch(int ch, struct sprintbuf *b)
-{
-	b->cnt++;
-	if (b->buf < b->ebuf)
-		*b->buf++ = ch;
-}
-
-int
-vsnprintf(char *buf, int n, const char *fmt, va_list ap)
-{
-	struct sprintbuf b = {buf, buf+n-1, 0};
-
-	if (buf == NULL || n < 1)
-		return -E_INVAL;
-
-	// print the string to the buffer
-	vprintfmt((void*)sprintputch, &b, fmt, ap);
-
-	// null terminate the buffer
-	*b.buf = '\0';
-
-	return b.cnt;
-}
-
-int
-snprintf(char *buf, int n, const char *fmt, ...)
-{
-	va_list ap;
-	int rc;
-
-	va_start(ap, fmt);
-	rc = vsnprintf(buf, n, fmt, ap);
-	va_end(ap);
-
-	return rc;
-}
-
-
+// Stripped-down primitive printf-style formatting routines,
+// used in common by printf, sprintf, fprintf, etc.
+// This code is also used by both the kernel and user programs.
+
+#include <inc/types.h>
+#include <inc/stdio.h>
+#include <inc/string.h>
+#include <inc/stdarg.h>
+#include <inc/error.h>
+
+/*
+ * Space or zero padding and a field width are supported for the numeric
+ * formats only.
+ *
+ * The special format %e takes an integer error code
+ * and prints a string describing the error.
+ * The integer may be positive or negative,
+ * so that -E_NO_MEM and E_NO_MEM are equivalent.
+ */
+
+static const char * const error_string[MAXERROR] =
+{
+	[E_UNSPECIFIED]	= "unspecified error",
+	[E_BAD_ENV]	= "bad environment",
+	[E_INVAL]	= "invalid parameter",
+	[E_NO_MEM]	= "out of memory",
+	[E_NO_FREE_ENV]	= "out of environments",
+	[E_FAULT]	= "segmentation fault",
+};
+
+/*
+ * Print a number (base <= 16) in reverse order,
+ * using specified putch function and associated pointer putdat.
+ */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+	 unsigned long long num, unsigned base, int width, int padc)
+{
+	// first recursively print all preceding (more significant) digits
+	if (num >= base) {
+		printnum(putch, putdat, num / base, base, width - 1, padc);
+	} else {
+		// print any needed pad characters before first digit
+		while (--width > 0)
+			putch(padc, putdat);
+	}
+
+	// then print this (the least significant) digit
+	putch("0123456789abcdef"[num % base], putdat);
+}
+
+// Get an unsigned int of various possible sizes from a varargs list,
+// depending on the lflag parameter.
+static unsigned long long
+getuint(va_list *ap, int lflag)
+{
+	if (lflag >= 2)
+		return va_arg(*ap, unsigned long long);
+	else if (lflag)
+		return va_arg(*ap, unsigned long);
+	else
+		return va_arg(*ap, unsigned int);
+}
+
+// Same as getuint but signed - can't use getuint
+// because of sign extension
+static long long
+getint(va_list *ap, int lflag)
+{
+	if (lflag >= 2)
+		return va_arg(*ap, long long);
+	else if (lflag)
+		return va_arg(*ap, long);
+	else
+		return va_arg(*ap, int);
+}
+
+
+// Main function to format and print a string.
+void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);
+
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
+{
+	register const char *p;
+	register int ch, err;
+	unsigned long long num;
+	int base, lflag, width, precision, altflag;
+	char padc;
+
+	while (1) {
+		while ((ch = *(unsigned char *) fmt++) != '%') {
+			if (ch == '\0')
+				return;
+			putch(ch, putdat);
+		}
+
+		// Process a %-escape sequence
+		padc = ' ';
+		width = -1;
+		precision = -1;
+		lflag = 0;
+		altflag = 0;
+	reswitch:
+		switch (ch = *(unsigned char *) fmt++) {
+
+		// flag to pad on the right
+		case '-':
+			padc = '-';
+			goto reswitch;
+
+		// flag to pad with 0's instead of spaces
+		case '0':
+			padc = '0';
+			goto reswitch;
+
+		// width field
+		case '1':
+		case '2':
+		case '3':
+		case '4':
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			for (precision = 0; ; ++fmt) {
+				precision = precision * 10 + ch - '0';
+				ch = *fmt;
+				if (ch < '0' || ch > '9')
+					break;
+			}
+			goto process_precision;
+
+		case '*':
+			precision = va_arg(ap, int);
+			goto process_precision;
+
+		case '.':
+			if (width < 0)
+				width = 0;
+			goto reswitch;
+
+		case '#':
+			altflag = 1;
+			goto reswitch;
+
+		process_precision:
+			if (width < 0)
+				width = precision, precision = -1;
+			goto reswitch;
+
+		// long flag (doubled for long long)
+		case 'l':
+			lflag++;
+			goto reswitch;
+
+		// character
+		case 'c':
+			putch(va_arg(ap, int), putdat);
+			break;
+
+		// error message
+		case 'e':
+			err = va_arg(ap, int);
+			if (err < 0)
+				err = -err;
+			if (err >= MAXERROR || (p = error_string[err]) == NULL)
+				printfmt(putch, putdat, "error %d", err);
+			else
+				printfmt(putch, putdat, "%s", p);
+			break;
+
+		// string
+		case 's':
+			if ((p = va_arg(ap, char *)) == NULL)
+				p = "(null)";
+			if (width > 0 && padc != '-')
+				for (width -= strnlen(p, precision); width > 0; width--)
+					putch(padc, putdat);
+			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
+				if (altflag && (ch < ' ' || ch > '~'))
+					putch('?', putdat);
+				else
+					putch(ch, putdat);
+			for (; width > 0; width--)
+				putch(' ', putdat);
+			break;
+
+		// (signed) decimal
+		case 'd':
+			num = getint(&ap, lflag);
+			if ((long long) num < 0) {
+				putch('-', putdat);
+				num = -(long long) num;
+			}
+			base = 10;
+			goto number;
+
+		// unsigned decimal
+		case 'u':
+			num = getuint(&ap, lflag);
+			base = 10;
+			goto number;
+
+		// (unsigned) octal
+		case 'o':
+			num = getuint(&ap, lflag);
+			base = 8;
+			goto number;
+
+		// pointer
+		case 'p':
+			putch('0', putdat);
+			putch('x', putdat);
+			num = (unsigned long long)
+				(uintptr_t) va_arg(ap, void *);
+			base = 16;
+			goto number;
+
+		// (unsigned) hexadecimal
+		case 'x':
+			num = getuint(&ap, lflag);
+			base = 16;
+		number:
+			printnum(putch, putdat, num, base, width, padc);
+			break;
+
+		// escaped '%' character
+		case '%':
+			putch(ch, putdat);
+			break;
+
+		// unrecognized escape sequence - just print it literally
+		default:
+			putch('%', putdat);
+			for (fmt--; fmt[-1] != '%'; fmt--)
+				/* do nothing */;
+			break;
+		}
+	}
+}
+
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
+{
+	va_list ap;
+
+	va_start(ap, fmt);
+	vprintfmt(putch, putdat, fmt, ap);
+	va_end(ap);
+}
+
+struct sprintbuf {
+	char *buf;
+	char *ebuf;
+	int cnt;
+};
+
+static void
+sprintputch(int ch, struct sprintbuf *b)
+{
+	b->cnt++;
+	if (b->buf < b->ebuf)
+		*b->buf++ = ch;
+}
+
+int
+vsnprintf(char *buf, int n, const char *fmt, va_list ap)
+{
+	struct sprintbuf b = {buf, buf+n-1, 0};
+
+	if (buf == NULL || n < 1)
+		return -E_INVAL;
+
+	// print the string to the buffer
+	vprintfmt((void*)sprintputch, &b, fmt, ap);
+
+	// null terminate the buffer
+	*b.buf = '\0';
+
+	return b.cnt;
+}
+
+int
+snprintf(char *buf, int n, const char *fmt, ...)
+{
+	va_list ap;
+	int rc;
+
+	va_start(ap, fmt);
+	rc = vsnprintf(buf, n, fmt, ap);
+	va_end(ap);
+
+	return rc;
+}
+
+
